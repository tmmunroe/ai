\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.5in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\title{COMS 4701 - Homework 2 - Written}
\author
{
Turner Mandeville
\and tmm2169
}


\begin{document}
    \maketitle

    \section*{Question 1}
    Since h1(n) and h2(n) are admissible, by definition, the following relationships are true:
    
    \forall n$, h_1(n) \leq h*(n)$, and
    
    \forall n$, h_2(n) \leq h*(n)
    
    \newline
    \newline
    \begin{enumerate}
        \item $h(n) = min\{h_1(n), h_2(n)\}$ is admissible
        
        For any n, let H(n) = \{h_1(n), h_2(n)\}
        
        From the definition of h(n), it follows that h(n) has either the value h_1(n) or h_2(n), and so, \forall n, h(n) \in H(n)
        
        Since h_1 and h_2 are admissible, and combining them forms the set H, we know that
        
        \forall n, \forall elements \in H(n), element <= h*(n)
        
        Since by the definition of h it is true that \forall n$, h(n) must come from the set H(n), it follows that \forall n, h(n) <= h*(n)
        $
        
        \item $h(n) = max\{h_1(n), h_2(n)\}$ is admissible
        
        Same proof as (1)
        
        \item $h(n) = w*h_1(n) + (1-w)*h_2(n), $where $0 \leq w \leq 1$ is admissible
        \newline
        Rearranging h(n), $h(n) = w*(h_1(n) - h_2(n)) + h_2(n)$
        \newline
        There are three possible conditions: 
        \begin{enumerate}
            \item $h_1(n) > h_2(n) => h_1(n) - h_2(n) > 0$
            \newline
            $0 \leq w \leq 1 =>$
            \newline
            $0 \leq w * (h_1(n) - h_2(n)) \leq h_1(n) - h_2(n) =>$
            \newline
            $h_2(n) \leq w * (h_1(n) - h_2(n)) + h_2(n) \leq h_1(n) =>$
            \newline
            $h_2(n) \leq h(n) \leq h_1(n) =>$
            \newline
            $h(n) \leq h_1(n) \leq h*(n)$
            
            \item $h_1(n) < h_2(n) => h_1(n) - h_2(n) < 0$
            \newline
            $0 \leq w \leq 1 =>$
            \newline
            $0 \geq w * (h_1(n) - h_2(n)) \geq h_1(n) - h_2(n) =>$
            \newline
            $h_2(n) \geq w * (h_1(n) - h_2(n)) + h_2(n) \geq h_1(n) =>$
            \newline
            $h_2(n) \geq h(n) \geq h_1(n) =>$
            \newline
            $h*(n) \geq h_2(n) \geq h(n)$
            \item $h_1(n) = h_2(n) => h_1(n) - h_2(n) = 0$
            \newline
            $h(n) = w*(h_1(n) - h_2(n)) + h_2(n) => $
            \newline
            $h(n) = h_2(n) \leq h*(n)$
        \end{enumerate}
        So, under all conditions, $h(n) \leq h*(n)$
        
    \end{enumerate}
    
    
    
    \newpage
    \section*{Question 2}
    Provide an upper bound on the size of the state space in the 8-puzzle game.
    \newline
    \newline
    Let a given state be denoted by an ordered list of the values in $\{0, 1, 2, ..., N\}$ where no value is repeated, 0 indicates the empty spot, and a particular index in the list corresponds to a particular position in the N-puzzle board.\newline
    
    Then, the state space, or set of all possible states, is all permutations of the ordered list $[0,1,2,...,N]$.\newline
    
    The upper bound on the state space is given by the number of possible permutations. To get the number of possible permutations, we can imagine walking through the ordered list, and for each index, selecting one of the values in the set $\{0, 1, 2, ..., N\}$ that has not already been selected for a previous index. That gives us:\newline
    
    $(N) * (N-1) * ... * 1 = N!$, which is the upper bound
    \newline
    For the 8-Puzzle, N=8. 
    \newline Upper bound = $8!$
    
    \newpage
    \section*{Question 3}
    \begin{enumerate}
        \item How many possible states are there in total?
        \newline
        For each column $c$, there are 6 possible positions for the queen in that column, $Q_c$. The total number of possible states is then:
        \newline
        total number of states $= 6 * 6 * 6 * 6 * 6 * 6 = 6^6$
        
        \item How many successor states are there for each state?
        \newline
        For each state, a successor state shifts one queen to a new position in it's column, For each queen, there are 5 possible positions to which it could be moved. The total number of successor states is then the total number of possible moves that could be made:
        \newline
        total number of successor states $= 5 + 5 + 5 + 5 + 5 + 5 = 5 * 6 = 30$
        
        \item What is the fitness function for the given state?
        
        Non-Attacking pairs:
        \newline
        $Q_1 -> { Q_2, Q_4, Q_5 }$
        \newline
        $Q_2 -> { Q_3, Q_5, Q_6 }$
        \newline
        $Q_3 -> { Q_4, Q_5, Q_6 }$
        \newline
        $Q_4 -> {empty}$
        \newline
        $Q_5 -> {empty}$
        \newline
        $Q_6 -> {empty}$
        \newline
        The fitness function is the sum of the sizes of the sets above, which denote which queens, $Q_j$ are attacking/being attacked by a queen, $Q_i$, such that $i<j$.
        \newline
        number of non-attacking pairs $ = 9$
        \item What genetic operator should we use to implement the successor function described in the problem (move a single queen to another square in the same column)?
        
        Mutation would be the most natural operator in this case, where we want to start with an individual board, move a single queen to a new spot on it's column, and guarantee that the state changes (the queen does not stay in the same spot). The one caveat is that we typically saw that mutation was applied with a small probability. The probability would need to be set to 1 in order to guarantee a state change.
    \end{enumerate}
    \newpage
    \section*{Question 4}
    Provide three advantages and three disadvantages of using local search algorithms.
    \newline
    Advantages
    \begin{itemize}
        \item Requires fewer resources- brute force search algorithms, such as DFS and BFS, require storing some portion of a search tree to represent the state space. This implies storing more than the current node and its immediate successors. With local search, only the current state and it's immediate successors need to be stored.
        \item Does not require a search tree- BFS and DFS require search trees, which adds a layer of complexity to their data structures and algorithms. With local search, only the immediate node and it's successors are required, which means that the most complex data structure (outside of the state representation) is a list.
        \item Can find good enough solutions- if an optimal solution is not needed, then local search can find "good enough" solutions that are locally optimal or satisfy some objective function.
    \end{itemize}
    \newline
    Disadvantages
    \begin{itemize}
        \item Not optimal - local search is not guaranteed to find optimal solutions because it does not systematically search a full state space
        \item Can get stuck - particularly with hill climbing algorithms, local search algorithms can get stuck if there is not a clearly superior successor to the current state.
        \item Requires tuning of parameters - particularly with genetic algorithms, there are a lot of parameters to control when certain operators are applied, to what members of the population they are applied, and when to terminate the search. Likewise, for hill-search algorithms, techniques can be used to reduce the likelihood that a search will get stuck, but they require parameters to determine how much "effort" to put in to getting unstuck.   
    \end{itemize}
\end{document}
